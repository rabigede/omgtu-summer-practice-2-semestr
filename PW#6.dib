#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!markdown

// здесь писать код

#!markdown

#!csharp

#r "nuget:ScottPlot, 5.0.36"

using System.Threading;
using System.Diagnostics;
using System.Collections.Concurrent;
using Microsoft.DotNet.Interactive.Formatting;

Queue<string> unsafeQueue = new();
BlockingCollection<string> blockColl = new();
ConcurrentQueue<string> queueSafe = new();

static ManualResetEvent manualResetEvent = new(false);

Stopwatch clock = new();

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(1000, 400)), HtmlFormatter.MimeType);

#!markdown

#!csharp

List<long> allTicks = new();

for (int k = 0; k < 10; k++)
{
    clock.Start();
    for (int i = 0; i < 1_000_000; i++)
        unsafeQueue.Enqueue("_message_");

    for (int i = 0; i < 1_000_000; i++)
        unsafeQueue.Dequeue();

    clock.Stop();

    allTicks.Add(clock.ElapsedTicks);
    clock.Reset();
}

Console.WriteLine(allTicks.Average());

ScottPlot.Plot plt = new();
plt.Add.Scatter(allTicks, Enumerable.Range(1, 10).ToList());

plt

#!markdown

#!csharp

List<long> allTicks = new();

for (int k = 0; k < 10; k++)
{
    Task writeData = Task.Run(() => {
        manualResetEvent.WaitOne();
        clock.Start();

        for (int i = 0; i < 1_000_000; i++)
            blockColl.Add("_message_");
    });

    Task readData = Task.Run(() => {
        manualResetEvent.Set();
        
        for (int i = 0; i < 1_000_000; i++)
            blockColl.Take();

        clock.Stop();
        allTicks.Add(clock.ElapsedTicks);
    });

    Task.WaitAll(writeData, readData);
    manualResetEvent.Reset();
    clock.Reset();
}

Console.WriteLine(allTicks.Average());

ScottPlot.Plot plt = new();
plt.Add.Scatter(allTicks, Enumerable.Range(1, 10).ToList());

plt

#!markdown

#!csharp

List<long> allTicks = new();

for (int k = 0; k < 10; k++)
{
    Task writeData = Task.Run(() => {
        manualResetEvent.WaitOne();
        clock.Start();

        for (int i = 0; i < 1_000_000; i++)
            queueSafe.Enqueue("_message_");
    });

    Task readData = Task.Run(() => {
        manualResetEvent.Set();
        
        for (int i = 0; i < 1_000_000; i++)
            queueSafe.TryDequeue(out string message);

        clock.Stop();
        allTicks.Add(clock.ElapsedTicks);
    });

    Task.WaitAll(writeData, readData);
    manualResetEvent.Reset();
    clock.Reset();
}

Console.WriteLine(allTicks.Average());

ScottPlot.Plot plt = new();
plt.Add.Scatter(allTicks, Enumerable.Range(1, 10).ToList());

plt

#!markdown

ВЫВОД

#!markdown

самая быстрая потокобезопасная очередь - ConcurrentQueue.
она быстрее непотокобезопасной на 20%

среднее количество тиков для непотокобезопасной очереди: 159485.1

среднее количество тиков для BlockingColection: 1662137.8

среднее количество тиков для  ConcurrentQueue:  128106.6
