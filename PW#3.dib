#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System.Threading;
using System.Diagnostics;

class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //

    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        double result = 0.0;
        Barrier barrier = new Barrier(threadsnumber + 1);
        Thread[] threads = new Thread[threadsnumber];
        double smallTrapSize = (b - a) / threadsnumber;

        for (int i = 0; i < threadsnumber; i++)
        {
            double start = a + i * smallTrapSize;
            double end = start + smallTrapSize;
            threads[i] = new Thread(() =>
            {
                double partintegral = 0;
                int step_count = Convert.ToInt32((end - start) / step);
                for (int j = 0; j < step_count; j++)
                {
                    double x = start + j * step;
                    double y = Math.Min(x + step, end);
                    partintegral += (function(x) + function(y)) * 0.5 * (y - x);
                }
                result += partintegral;
                barrier.SignalAndWait();
            });

            threads[i].Start();
        }
        barrier.SignalAndWait();
        return result;
    }
}

#!csharp

#r "nuget:ScottPlot, 5.0.36"
using Microsoft.DotNet.Interactive.Formatting;

int[] dataX = new int[6];
double[] dataY = new double[6];
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 500)), HtmlFormatter.MimeType);
ScottPlot.Plot plt = new();

var SIN = (double x) => Math.Sin(x);

for (int i = 1; i < 6 +1; i++) //перебор каждого значения шага (1e-1, 1e-2, 1 e-3, 1e-4, 1e-5, 1e-6)
{
    double total = 0;
    Console.WriteLine(i);
    for (int j = 0; j < 20; j++) //замер времени с заданным значнием шага 20 раз для статистики
    {
        
        Stopwatch stopWatch = new Stopwatch();
        stopWatch.Start();
        
        DefiniteIntegral.Solve(-100, 100, SIN, Convert.ToDouble($"1e-{i}"), 5); //например, 5 потоков
    
        stopWatch.Stop();
        total += stopWatch.ElapsedMilliseconds;

    }
    dataX[i-1]=i;
    dataY[i-1]=total/20;
    Console.WriteLine($"Всего: {total/20} мс");
}
plt.Add.Scatter(dataX, dataY);
plt

#!markdown

по результатам теста видно, что быстрее всего выполняется программа с шагом 1е-2 (0.05 мс). время выполнения программ большое, вероятно, из-за слабости ноутбука.

#!csharp

#r "nuget:ScottPlot, 5.0.36"
using Microsoft.DotNet.Interactive.Formatting;

int countofThreads = 20;

int[] dataX = new int[countofThreads];
double[] dataY = new double[countofThreads];
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 500)), HtmlFormatter.MimeType);
ScottPlot.Plot plt = new();

var SIN = (double x) => Math.Sin(x);

for (int i = 1; i < countofThreads +1; i++) //для каждого количества потоков
{
    double total = 0;
    Console.WriteLine(i);
    for (int j = 0; j < 100; j++) //прогон 100 раз для статистики
    {
        
        Stopwatch stopWatch = new Stopwatch();
        stopWatch.Start();
        
        DefiniteIntegral.Solve(-100, 100, SIN, 1e-2, i);
    
        stopWatch.Stop();
        total += stopWatch.ElapsedMilliseconds;

    }
    dataX[i-1]=i;
    dataY[i-1]=total/100;
    Console.WriteLine($"Всего: {total/100} мс");
}
plt.Add.Scatter(dataX, dataY);
plt

#!markdown

быстрее всего выполняется программа, содержащая 4 потока (0.01 мс)

#!markdown

однопоточный вариант

#!csharp

class DefiniteIntegralOnePotok
{
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    //

    public static double Solve(double a, double b, Func<double, double> function, double step)
    {
        double result = 0.0;
        int step_count = Convert.ToInt32((b - a) / step);

        for (int j = 0; j < step_count; j++)
        {
            double x = a + j * step;
            double y = Math.Min(x + step, b);
            result += (function(x) + function(y)) * 0.5 * (y - x);
        }

        return result;
    }
}

Assert.Equal(0, DefiniteIntegralOnePotok.Solve(-1, 1, X, 1e-4), 1e-4);

Assert.Equal(0, DefiniteIntegralOnePotok.Solve(-1, 1, SIN, 1e-5), 1e-4);

Assert.Equal(50, DefiniteIntegralOnePotok.Solve(0, 10, X, 1e-6), 1e-5);

#!markdown

сравнение лучшей многопоточной и однопоточной (работают одинаковое количество времени в данной ситуации)

#!csharp

Stopwatch withThreadsTime = new Stopwatch();
withThreadsTime.Start();
DefiniteIntegralOnePotok.Solve(-100, 100, SIN, 1e-2);
withThreadsTime.Stop();
TimeSpan ts = withThreadsTime.Elapsed;
string elapsedTimeWT = String.Format("{0:00}:{1:000}:{2:000}",
             ts.Seconds,
            ts.Milliseconds, ts.Microseconds);
Console.WriteLine(elapsedTimeWT);

Stopwatch NoThreadsTime = new Stopwatch();
NoThreadsTime.Start();
DefiniteIntegral.Solve(-100, 100, SIN, 1e-2, 4);
NoThreadsTime.Stop();
string elapsedTimeNT = String.Format("{0:00}:{1:000}:{2:000}",
             ts.Seconds,
            ts.Milliseconds, ts.Microseconds);
Console.WriteLine(elapsedTimeNT);
